WHITESPACE = _{ " " | "\r\n" | "\n" | "\t" }

keywords = _{
    "fn" | 
    "obj" |
    "print" |
    "return" |
    "if" |
    "else" |
    "true" |
    "false" |
    "modify" |
    "const" |
    "self" | 
    "while"
}

integer = @{ '0'..'9' ~ ('0'..'9' | ("_" ~ ('0'..'9')))* }

hex_digit = _{ '0'..'9' | 'a'..'f' | 'A'..'F' }
hex_int = @{ "0x" ~ (hex_digit ~ (hex_digit | ("_" ~ (hex_digit)))*) }

byte = @{ "0b" ~ ('0'..'1' ~ ('0'..'1' | ("_" ~ ('0'..'1')))*) }
float = @{ integer ~ "." ~ integer }

number = { hex_int | byte | float | integer }
boolean = { "true" | "false" }

unary_minus = { "-" }
not = { "!" }

allow_bin_op = _{ callable | boolean | ident | number | string }

math_primary = _{ allow_bin_op | "(" ~ math_expr ~ ")" }
math_atom = _{ (unary_minus | not)? ~ math_primary }

bin_op = _{ add | subtract | multiply | divide | modulo | lte | gte | lt | gt | eq | neq | and | or | xor }
add = { "+" }
subtract = { "-" }
multiply = { "*" }
divide = { "/" }
modulo = { "%" }

lt = { "<" }
gt = { ">" }
lte = { "<=" }
gte = { ">=" }
eq = { "==" }
neq = { "!=" }

and = { "&&" }
or = { "||" }
xor = { "^" }

math_expr = { math_atom ~ (bin_op ~ math_atom)* }

escape_character = _{ "\\" | "r" | "n" }
escape_sequence = @{ "\\" ~ escape_character }

string = @{ "\"" ~ (("\\\"") | (!("\"") ~ ANY))* ~ "\"" }


ident_chars = _{ (('a'..'z') | ('0'..'9') | "_") }

ident = @{ !('0'..'9') ~ ident_chars+ }
type = { function_type | list_type_open_only | list_type | ident }
ident_type = _{ ident ~ ":" ~ type }

function_arguments = { (value ~ ("," ~ value)*)? }
callable = { ident ~ "(" ~ function_arguments ~ ")" }

block = { "{" ~ declaration* ~ "}" }

function_parameters = { ((ident ~ (":" ~ type)?))? ~ ("," ~ ((ident ~ (":" ~ type)?)))* }

function_type = { "fn" ~ "(" ~ (type ~ ("," ~ type)*)? ~ ")" ~ function_return_type?  }
// allow braces around the return type in case it is long
function_return_type = { "->" ~ (type | ("(" ~ type ~ ")")) }
function = { "fn" ~ "(" ~ (function_parameters) ~ ")" ~ function_return_type? ~ block }

list = { "[" ~ value? ~ ("," ~ value)* ~ "]" }
open_ended_type = { type ~ "..." }
list_type = { "[" ~ type? ~ ("," ~ (type ~ !("...")))* ~ ("," ~ open_ended_type)? ~ "]" }
list_type_open_only = { "[" ~ open_ended_type ~ "]" }
list_index = { ("[" ~ value ~ "]")+ }

value = { (function | math_expr | ident | string | list) ~ list_index? }

assignment_flag = { "modify" | "const" }
// bad_assignment_flag = { &ident }
assignment_flags = { assignment_flag ~ assignment_flag* }
assignment_no_type = { ident ~ "=" ~ value }
assignment_type = { ident ~ ":" ~ type ~ "=" ~ value }
assignment = { (assignment_flags ~ (assignment_no_type | assignment_type)) | (assignment_no_type | assignment_type) }

else_statement = { "else" ~ (block | if_statement) }

if_statement = { "if" ~ value ~ block ~ else_statement? }

while_loop = { "while" ~ value ~ block }

number_loop_inclusive = { "through" }
number_loop_exclusive = { "to" }

number_loop_bind_name = { "," ~ ident }

number_loop_step = { "step" ~ value }

number_loop = { "from" ~ value ~ (number_loop_inclusive | number_loop_exclusive) ~ value ~ number_loop_step? ~ number_loop_bind_name? ~ block }
continue_statement = { "continue" }
break_statement = { "break" }

print_statement = { "print" ~ value }

return_statement = { "return" ~ value? }

declaration = { assignment | callable | print_statement | return_statement | continue_statement | break_statement | if_statement | while_loop | number_loop }

file = {
    SOI ~
    (declaration ~ NEWLINE*)* ~
    EOI
}